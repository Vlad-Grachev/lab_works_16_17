# Лабораторная работа №7. Таблицы ### Требования к лабораторной работеВ рамках данной лабораторной работы была поставлена задача создания программных средств, поддерживающих табличные динамические структуры данных (таблицы) и базовые операции над ними:-	поиск записи;-	вставка записи (без дублирования);-	удаление записи.В лабораторной работе были реализованы следующие типы таблиц:-	просмотровые (неупорядоченные);-	упорядоченные (сортированные);-	таблицы со структурами хранения на основе деревьев поиска;Был разработан интерфейс доступа к операциям поиска, вставки и удаления, не зависящий от способа организации таблицы.## Структура проекта**Результатом выполнения работы является следующий набор файлов:**- TTabRecord.h, TTabRecord.cpp – модуль с классом объектов-значений для записей таблицы;- TTable.h – абстрактный базовый класс, содержит спецификации методов таблицы;- TArrayTable.h, TArrayTable.cpp – абстрактный базовый класс для таблиц с непрерывной памятью;- TScanTable.h, TScanTable.cpp – модуль с классом, обеспечивающим реализацию просматриваемых таблиц;- TSortTable.h, TSortTable.cpp – модуль с классом, обеспечивающим реализацию упорядоченных таблиц;- TTreeNode.h, TTreeNode.cpp – модуль с абстрактным базовым классом объектов-значений для деревьев;- TTreeTable.h, TTreeTable.cpp – модуль с классом, реализующим таблицы в виде деревьев поиска;- TBalanceNode.h, TBalanceNode.cpp – модуль с базовым классом объектов-значений для сбалансированных деревьев;- TBalanceTree.h, TBalanceTree.cpp – модуль с классом, реализующим таблицы в виде сбалансированных деревьев поиска;Реализация класс объектов-значений для записей таблицы __TTabRecord__:```c++// TTabRecord.h// Класс объектов-значений для записей таблицы#ifndef _TREACORD_H_#define _TREACORD_H_#include <iostream>#include <include/TDatValue.h>using namespace std;typedef string TKey;     // тип ключа записиclass TTabRecord : public TDatValue {    protected:        TKey Key;   // ключ записи    PTDatValue pValue;   // указатель на значение  public:      TTabRecord(TKey k = "", PTDatValue pVal = NULL); // конструктор       void SetKey(TKey k); // установить значение ключа      TKey GetKey(void) const;  // получить значение ключа      void SetValuePtr(PTDatValue p); // установить указатель на данные      PTDatValue GetValuePtr(void) const; // получить указатель на данные      virtual TDatValue * GetCopy(); // изготовить копию      TTabRecord& operator = (TTabRecord &tr); // присваивание      // сравнение      virtual bool operator == (const TTabRecord &tr);      virtual bool operator < (const TTabRecord &tr);      virtual bool operator > (const TTabRecord &tr);      //дружественные классы для различных типов таблиц, см. далее      friend class TArrayTable;      friend class TScanTable;      friend class TSortTable;      friend class TTreeNode;      friend class TTreeTable;      friend class TArrayHash;      friend class TListHash;};typedef TTabRecord* PTTabRecord;#endif// TTabRecord.h.cpp// Класс объектов-значений для записей таблицы#include "include/TTabRecord.h"TTabRecord::TTabRecord(TKey k, PTDatValue pVal){    Key = k;    pValue = pVal;}        /*-------------------------------------------*/void TTabRecord::SetKey(TKey k) {    Key = k;}        /*-------------------------------------------*/TKey TTabRecord::GetKey() const {    return Key;}        /*-------------------------------------------*/void TTabRecord::SetValuePtr(PTDatValue p) {    pValue = p;}        /*-------------------------------------------*/PTDatValue TTabRecord::GetValuePtr() const {    return pValue;}        /*-------------------------------------------*/TDatValue* TTabRecord::GetCopy(){    TDatValue* temp = new TTabRecord(Key, pValue);    return temp;}        /*-------------------------------------------*/TTabRecord& TTabRecord::operator=(TTabRecord& tr){    Key = tr.Key;    pValue = tr.pValue;    return *this;}        /*-------------------------------------------*/bool TTabRecord::operator==(const TTabRecord& tr){    return Key == tr.Key;}    /*-------------------------------------------*/bool TTabRecord::operator<(const TTabRecord& tr){    return Key < tr.Key;}    /*-------------------------------------------*/bool TTabRecord::operator>(const TTabRecord& tr){    return Key > tr.Key;}```Спецификация абстрактного класса __TTable__:```c++// TTable.h// Таблицы - базовый класс#ifndef _TTABLE_H_#define _TTABLE_H_#include <string>#include "include/TDataCom.h"#include "include/TDatValue.h"#include "include/TTabRecord.h"#define TabOK          0 // ошибок нет#define TabEmpty    -101 // таблица полна#define TabFull     -102 // таблица пуста#define TabNoRec    -103 // нет записи#define TabRecDbl   -104 // дублирование записи#define TabNoMem    -105 // нет памятиtypedef std::string TKey;class TTable : public TDataCom{protected:    int DataCount;		// число записей в таблице    int Efficiency;		// показатель эффективности выполнения операцииpublic:    TTable(){ DataCount = 0; Efficiency = 0; }    virtual ~TTable() {};    // информационные методы    int GetDataCount() const { return DataCount; }    // к-во записей    int GetEfficiency() const { return Efficiency; } // эффективность    int IsEmpty() const { return DataCount == 0; }   //пуста?    virtual bool IsFull() const = 0;                 // таблица заполнена?    // доступ    virtual TKey GetKey(void) const = 0;    virtual PTDatValue GetValuePtr(void) const = 0;    // основные методы    virtual PTDatValue FindRecord(TKey k) = 0; // найти запись    virtual void InsRecord(TKey k, PTDatValue pVal) = 0; // вставить    virtual void DelRecord(TKey k) = 0;        // удалить запись    // навигация    virtual void Reset(void) = 0; // установить на первую запись    virtual bool IsTabEnded(void) const = 0; // таблица завершена?    virtual int GoNext(void) = 0; // переход к следующей записи    // (=1 после применения для последней записи таблицы)};#endif```Реализация класса __TArrayTable__:```c++// TArrayTable.h// Таблицы - базовый класс для таблиц с непрерывной памятью#ifndef _TARRAYTABLE_H_#define _TARRAYTABLE_H_#include "include/TTable.h"#include "include/TTabRecord.h"enum TDataPos { FIRST_POS, CURRENT_POS, LAST_POS };class TArrayTable : public TTable{protected:    PTTabRecord *pRecs;				// Память для записей таблицы    int TabSize;					// макс. число записей в таблице    int CurrPos;					// номер текущей записиpublic:    static const int TAB_MAX_SIZE = 25;    TArrayTable(int size = TAB_MAX_SIZE);    ~TArrayTable();    // информационные методы    virtual bool IsFull() const { return DataCount >= TabSize; } // таблица заполнена?    int GetTabSize() const { return TabSize; }    // доступ    virtual TKey GetKey() const { return GetKey(CURRENT_POS); }    virtual PTDatValue GetValuePtr() const override { return GetValuePTR(CURRENT_POS); }    virtual TKey GetKey(TDataPos mode) const;    virtual PTDatValue GetValuePTR(TDataPos mode) const;    PTTabRecord GetCurrRecord();    // навигация    virtual void Reset();    virtual bool IsTabEnded() const;    virtual int GoNext();    virtual int SetCurrentPos(int pos);    int GetCurrentPos() const { return CurrPos; }    friend TSortTable;};#endif// TArrayTable.cpp// Таблицы - базовый класс для таблиц с непрерывной памятью#include "include/TArrayTable.h"TArrayTable::TArrayTable(int size) {    pRecs = new PTTabRecord[size];    for (int i = 0; i < size; ++i) pRecs[i] = nullptr;    TabSize = size;    DataCount = CurrPos = 0;}        /*-------------------------------------------*/TArrayTable::~TArrayTable(){    for (int i = 0; i < DataCount; ++i)        delete pRecs[i];    delete[] pRecs;}        /*-------------------------------------------*/TKey TArrayTable::GetKey(TDataPos mode) const{    int pos = -1;    switch (mode)    {    case TDataPos::FIRST_POS:        pos = 0;        break;    case TDataPos::LAST_POS:        pos = DataCount - 1;        break;    case TDataPos::CURRENT_POS:        pos = CurrPos;        break;    }    return (pos != -1) ? pRecs[pos]->Key : "";}        /*-------------------------------------------*/PTDatValue TArrayTable::GetValuePTR(TDataPos mode) const{    int pos = -1;    switch (mode)    {    case TDataPos::FIRST_POS:        pos = 0;        break;    case TDataPos::LAST_POS:        pos = DataCount - 1;        break;    case TDataPos::CURRENT_POS:        pos = CurrPos;        break;    }    return (pos != -1) ? pRecs[pos]->pValue : nullptr;}        /*-------------------------------------------*/PTTabRecord TArrayTable::GetCurrRecord() {    return pRecs[CurrPos];}        /*-------------------------------------------*/void TArrayTable::Reset() {    CurrPos = 0;}        /*-------------------------------------------*/bool TArrayTable::IsTabEnded() const{    return CurrPos >= DataCount;}        /*-------------------------------------------*/int TArrayTable::GoNext(){    if (!IsTabEnded())        CurrPos++;    else        SetRetCode(TabFull);    return GetRetCode();}        /*-------------------------------------------*/int TArrayTable::SetCurrentPos(int pos){    if (pos < 0 || pos >= DataCount)        SetRetCode(TabNoRec);    else        CurrPos = pos;    return GetRetCode();}```Реализация класса __TScanTable__:```c++// TScanTable.h// Просматриваемые таблицы#ifndef _TSCANTABLE_H_#define _TSCANTABLE_H_#include "include/TArrayTable.h"class TScanTable : public TArrayTable{public:    TScanTable(int Size) : TArrayTable(Size) { }    // основные методы    virtual PTDatValue FindRecord(TKey k); // найти запись    virtual void InsRecord(TKey k, PTDatValue pVal); // вставить запись    virtual void DelRecord(TKey k); // удалить запись};#endif// TScanTable.cpp// Просматриваемые таблицы#include "include/TScanTable.h"PTDatValue TScanTable::FindRecord(TKey k){    SetRetCode(TabOK);    for (int i = 0; i < TabSize; ++i) {        if (pRecs[i] != nullptr)        if (pRecs[i]->GetKey() == k) {            return pRecs[i]->GetValuePtr();        }    }    SetRetCode(TabNoRec);    return nullptr;}        /*-------------------------------------------*/void TScanTable::InsRecord(TKey k, PTDatValue pVal){    SetRetCode(TabNoRec);    for (int i = 0; i < TabSize; ++i) {        if (pRecs[i] == nullptr)        {            pRecs[i] = new TTabRecord(k, pVal);            DataCount++;            SetRetCode(TabOK);            break;        }    }}        /*-------------------------------------------*/void TScanTable::DelRecord(TKey k){    SetRetCode(TabNoRec);    for (int i = 0; i < TabSize; i++) {        if (pRecs[i] != nullptr)        if (pRecs[i]->GetKey() == k) {            delete pRecs[i];            pRecs[i] = pRecs[DataCount - 1];            pRecs[DataCount - 1] = nullptr;            DataCount--;            SetRetCode(TabOK);        }    }}```Реализация класса __TSortTable__:```c++// TSortTable.h// Упорядоченные таблицы#ifndef _SORT_TABLE_H_#define _SORT_TABLE_H_#include "TScanTable.h"enum TSortMethod { INSERT_SORT, MERGE_SORT, QUICK_SORT };class TSortTable : public TScanTable{protected:    TSortMethod SortMethod;    void SortData();    void InsertSort(PTTabRecord *pMem, int DataCount);    void MergeSort(PTTabRecord *pMem, int DataCount);    void MergeSorter(PTTabRecord* &pData, PTTabRecord* &pBuf, int Size);    void MergeData(PTTabRecord* &pData, PTTabRecord* &pBuff, int n1, int n2);    void QuickSort(PTTabRecord *pMem, int DataCount);    void QuickSplit(PTTabRecord *pData, int Size, int &Pivot);public:    TSortTable(int Size) : TScanTable(Size) { };    TSortTable & operator=(const TSortTable &tab);    TSortMethod GetSortMethod();    void SetSortMethod(TSortMethod method);    // основные методы    virtual PTDatValue FindRecord(TKey k) override final;    virtual void InsRecord(TKey k, PTDatValue pVal) override final;    virtual void DelRecord(TKey k) override final;};#endif// TSortTable.cpp// Упорядоченные таблицы#include "include/TSortTable.h"TSortTable & TSortTable::operator=(const TSortTable &tab){    if (pRecs != nullptr) {        for (int i = 0; i < DataCount; ++i)            delete pRecs[i];        delete[] pRecs;        pRecs = nullptr;    }    TabSize = tab.TabSize;    DataCount = tab.DataCount;    pRecs = new PTTabRecord[TabSize];    for (int i = 0; i < DataCount; ++i)        pRecs[i] = (PTTabRecord)tab.pRecs[i]->GetCopy();    SortData();    CurrPos = 0;    return *this;}        /*-------------------------------------------*/PTDatValue TSortTable::FindRecord(TKey k){    SetRetCode(TabNoRec);    PTDatValue result = nullptr;    if (DataCount > 0) {        int i, i1 = 0, i2 = DataCount - 1;        while (i1 <= i2) {            i = (i1 + i2) / 2;            if (pRecs[i]->GetKey() == k) {                result = pRecs[i]->GetValuePtr();                SetRetCode(TabOK);                break;            }            else if (pRecs[i]->GetKey() > k) {                i2 = i - 1;            }            else {                i1 = i + 1;            }        }    }    return result;}        /*-------------------------------------------*/void TSortTable::InsRecord(TKey k, PTDatValue pVal){    if (IsFull()) {        SetRetCode(TabFull);    }    else {        if (FindRecord(k) != nullptr) {            SetRetCode(TabRecDbl);        }        else {            SetRetCode(TabOK);            for (int i = DataCount; i > CurrPos; i--)                pRecs[i] = pRecs[i - 1];            pRecs[CurrPos] = new TTabRecord(k, pVal);            DataCount++;            SortData();        }    }}        /*-------------------------------------------*/void TSortTable::DelRecord(TKey k){    SetRetCode(TabNoRec);    for (int i = 0; i < DataCount; i++) {        if (pRecs[i]->GetKey() == k) {            delete pRecs[i];            for (int j = i; j < DataCount; j++)                pRecs[j] = pRecs[j + 1];            DataCount--;            SetRetCode(TabOK);        }    }}        /*-------------------------------------------*/TSortMethod TSortTable::GetSortMethod(){    return SortMethod;}        /*-------------------------------------------*/void TSortTable::SetSortMethod(TSortMethod method){    SortMethod = method;}        /*-------------------------------------------*/void TSortTable::SortData(){    switch (SortMethod) {    case TSortMethod::QUICK_SORT:        QuickSort(pRecs, DataCount);        break;    case TSortMethod::INSERT_SORT:        InsertSort(pRecs, DataCount);        break;    case TSortMethod::MERGE_SORT:        QuickSort(pRecs, DataCount);        break;    default:        InsertSort(pRecs, DataCount);        break;    }}        /*-------------------------------------------*/void TSortTable::InsertSort(PTTabRecord *pMem, int DataCount){    PTTabRecord pR;    for (int i = 1, j; i < DataCount; i++)    {        pR = pRecs[i];        for (j = i - 1; j >= 0; j--) {            if (pRecs[j]->GetKey() > pR->GetKey()) {                pRecs[j + 1] = pRecs[j];            }            else {                break;            }        }        pRecs[j + 1] = pR;    }}        /*-------------------------------------------*/void TSortTable::MergeSort(PTTabRecord * pMem, int DataCount){    PTTabRecord *pData = pRecs;    PTTabRecord *pBuff = new PTTabRecord[DataCount];    PTTabRecord *pTemp = pBuff;    MergeSorter(pData, pBuff, DataCount);    if (pData == pTemp) {        for (int i = 0; i < DataCount; i++)            pBuff[i] = pData[i];    }    delete pTemp;}        /*-------------------------------------------*/void TSortTable::MergeSorter(PTTabRecord *& pData, PTTabRecord *& pBuff, int Size){    int n1 = (Size + 1) / 2;    int n2 = Size - n1;    if (Size > 2) {        PTTabRecord *pDat2 = pData + n1, *pBuff2 = pBuff + n1;        MergeSorter(pData, pBuff, n1);        MergeSorter(pDat2, pBuff2, n2);    }    MergeData(pData, pBuff, n1, n2);}        /*-------------------------------------------*/void TSortTable::MergeData(PTTabRecord *& pData, PTTabRecord *& pBuff, int n1, int n2){    for (int i = 0; i < (n1 + n2); i++) {        pBuff[i] = pData[i];    }    PTTabRecord *&tmp = pData;    pData = pBuff;    pBuff = tmp;}        /*-------------------------------------------*/void TSortTable::QuickSort(PTTabRecord * pRecs, int DataCount){    int pivot; // индекс ведущего элемента    int n1, n2; // размеры разделенных блоков данных    if (DataCount > 1) {        QuickSplit(pRecs, DataCount, pivot);        n1 = pivot + 1;        n2 = DataCount - n1;        QuickSort(pRecs, n1 - 1);        QuickSort(pRecs + n1, n2);    }}        /*-------------------------------------------*/void TSortTable::QuickSplit(PTTabRecord * pData, int Size, int &Pivot){    PTTabRecord pPivot = pData[0], pTemp;    int i1 = 1, i2 = Size - 1;    while (i1 <= i2) {        while ((i1 < Size) && !(pData[i1]->GetKey() > pPivot->GetKey())) i1++;        while (pData[i2]->GetKey() > pPivot->GetKey()) i2--;        if (i1 < i2) {            pTemp = pData[i1];            pData[i1] = pData[i2];            pData[i2] = pTemp;        }    }    pData[0] = pData[i2];    pData[i2] = pPivot;    Pivot = i2;}```Класс объектов-значений для деревьев __TTreeNode__:```c++// TTreeNode.h// Таблицы - базовый (абстрактный класс) объектов значений для деревьев#ifndef _TREENODE_H_#define _TREENODE_H_#include "include/TTabRecord.h"class TTreeNode;typedef TTreeNode *PTTreeNode;class TTreeNode : public TTabRecord {protected:    PTTreeNode pLeft, pRight; // указатели на поддеревьяpublic:    TTreeNode(TKey k = "", PTDatValue pVal = nullptr, PTTreeNode pL = nullptr,        PTTreeNode pR = nullptr) : TTabRecord(k, pVal), pLeft(pL), pRight(pR) {};    PTTreeNode GetLeft(void) const;  // указатель на левое поддерево    PTTreeNode GetRight(void) const; // указатель на правое поддерево    virtual TDatValue * GetCopy() override;  // изготовить копию    friend class TTreeTable;    friend class TBalanceTree;};#endif// TTreeNode.cpp// Таблицы - базовый (абстрактный класс) объектов значений для деревьев#include "include/TTreeNode.h"PTTreeNode TTreeNode::GetLeft(void) const{    return pLeft;}        /*-------------------------------------------*/PTTreeNode TTreeNode::GetRight(void) const{    return pRight;}        /*-------------------------------------------*/TDatValue * TTreeNode::GetCopy(){    TTreeNode *tmp = new TTreeNode(Key, pValue, nullptr, nullptr);    return tmp;}```Реализация класса __TTreeTable__:```c++// TTreeTable.h// Таблицы со структурой хранения в виде деревьев поиска#ifndef _TREETABLE_H_#define _TREETABLE_H_#include <stack>#include "TTable.h"#include "TTreeNode.h"class  TTreeTable : public TTable {protected:    PTTreeNode pRoot;			// указатель на корень дерева    PTTreeNode *ppRef;			// адрес указателя на вершину-результата в FindRecord    PTTreeNode pCurrent;		// указатель на текущую вершину    int CurrPos;				// номер текущей вершины    std::stack < PTTreeNode> St;		// стек для итератора    void DeleteTreeTab(PTTreeNode pNode); // удалениеpublic:    TTreeTable() : TTable() { CurrPos = 0; pRoot = pCurrent = NULL; ppRef = NULL; }    ~TTreeTable() { DeleteTreeTab(pRoot); }				// деструктор    // информационные методы    virtual bool IsFull() const override;						// таблица заполнена?    //основные методы    virtual PTDatValue FindRecord(TKey k) override;				// найти запись    virtual void InsRecord(TKey k, PTDatValue pVal) override; 	// вставить    virtual void DelRecord(TKey k) override;					// удалить запись    // навигация    virtual TKey GetKey(void) const override;    virtual PTDatValue GetValuePtr(void) const override;    virtual void Reset(void) override;					// установить на первую запись    virtual bool IsTabEnded(void) const override;		// таблица завершена?    virtual int GoNext(void) override;					// переход к следующей записи};#endif// TTreeTable.cpp// Таблицы со структурой хранения в виде деревьев поиска#include "include/TTreeTable.h"bool TTreeTable::IsFull() const{    return false;}        /*-------------------------------------------*/PTDatValue TTreeTable::FindRecord(TKey k) {    PTTreeNode tmp = pRoot;    ppRef = &pRoot;    while (tmp != nullptr) {        if (tmp->GetKey() == k) break;        if (tmp->GetKey() < k) ppRef = &tmp->pRight;        else ppRef = &tmp->pLeft;        tmp = *ppRef;    }    if (tmp == nullptr) {        SetRetCode(TabNoRec);        return nullptr;    }    else {        SetRetCode(TabOK);        return tmp->GetValuePtr();    }}        /*-------------------------------------------*/void TTreeTable::InsRecord(TKey k, PTDatValue pVal){    if (IsFull()) {        SetRetCode(TabFull);    }    else {        if (FindRecord(k) != nullptr) {            SetRetCode(TabRecDbl);        }        else {            *ppRef = new TTreeNode(k, pVal);            DataCount++;        }    }}        /*-------------------------------------------*/void TTreeTable::DelRecord(TKey k){    if (FindRecord(k) == nullptr) {        SetRetCode(TabNoRec);    }    else {        PTTreeNode tmp = pRoot;        while (!St.empty())            St.pop();        while (tmp->GetKey() != k) {            St.push(tmp);            if (tmp->GetKey() < k)                tmp = tmp->GetRight();            else                tmp = tmp->GetLeft();        }        // удаление листа        if ((tmp->pLeft == nullptr) && (tmp->pRight == nullptr)) {            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = nullptr;                    else if (prev->GetLeft() == tmp)                        prev->pLeft = nullptr;                }            }            else {                pRoot = nullptr;            }            delete tmp;            DataCount--;        }        // удаление звена с одним потомком (справа)        else if (tmp->pLeft == nullptr) {            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = tmp->pRight;                    if (prev->GetLeft() == tmp)                        prev->pLeft = tmp->pRight;                }            }            else {                pRoot = tmp->GetRight();            }            delete tmp;            DataCount--;        }        // удаление звена с одним потомком (слева)        else if (tmp->pRight == nullptr) {            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = tmp->pLeft;                    if (prev->GetLeft() == tmp)                        prev->pLeft = tmp->pLeft;                }            }            else {                pRoot = tmp->GetLeft();            }            delete tmp;            DataCount--;        }        // удаление звена с двумя потомками        else {            PTTreeNode down_left = tmp->GetRight();            while (down_left->GetLeft() != nullptr)                down_left = down_left->pLeft;            down_left->pLeft = tmp->GetLeft();            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = tmp->pRight;                    if (prev->GetLeft() == tmp)                        prev->pLeft = tmp->pRight;                }            }            else {                pRoot = tmp->GetRight();            }            delete tmp;            DataCount--;        }    }}        /*-------------------------------------------*/TKey TTreeTable::GetKey(void) const{    return (pCurrent == nullptr) ? "" : pCurrent->GetKey();}PTDatValue TTreeTable::GetValuePtr(void) const{    return (pCurrent == nullptr) ? nullptr : pCurrent->GetValuePtr();}void TTreeTable::DeleteTreeTab(PTTreeNode pNode){    if (pNode != nullptr) {        DeleteTreeTab(pNode->GetLeft());        DeleteTreeTab(pNode->GetRight());        delete pNode;    }}        /*-------------------------------------------*/void TTreeTable::Reset(void){    PTTreeNode pNode = pCurrent = pRoot;    CurrPos = 0;    while (pNode != nullptr) {        St.push(pNode);        pCurrent = pNode;        pNode = pNode->GetLeft();    }    SetRetCode(TabOK);}bool TTreeTable::IsTabEnded(void) const{    return (CurrPos >= DataCount);}        /*-------------------------------------------*/int TTreeTable::GoNext(void){    CurrPos++;    if (!IsTabEnded() && (pCurrent != nullptr)) {        PTTreeNode pNode = pCurrent = pCurrent->GetRight();        St.pop();        while (pNode != nullptr) {            St.push(pNode);            pCurrent = pNode;            pNode = pNode->GetLeft();        }        if ((pCurrent == nullptr) && !St.empty())            pCurrent = St.top();    }    else SetRetCode(TabNoRec);    return GetRetCode();}```Класс объектов-значений для сбалансированных деревьев __TBalanceNode__:```c++// TBalanceNode.h// Таблицы - базовый класс объектов-значений для сбалансированных деревьев#ifndef _BALANCENODE_H_#define _BALANCENODE_H_#include "include/TTreeNode.h"enum class Bal { BalOK, BalLeft, BalRight };class  TBalanceNode : public TTreeNode {protected:    Bal Balance; // индекс балансировки вершиныpublic:    TBalanceNode(TKey k = "", PTDatValue pVal = NULL, PTTreeNode pL = NULL,        PTTreeNode pR = NULL, Bal bal = Bal::BalOK) : TTreeNode(k, pVal, pL, pR),        Balance(bal) {};			// конструктор    virtual TDatValue * GetCopy();  // изготовить копию    Bal GetBalance(void) const;    void SetBalance(Bal bal);    friend class TBalanceTree;};typedef TBalanceNode *PTBalanceNode;#endif// TBalanceNode.cpp// Таблицы - базовый класс объектов-значений для сбалансированных деревьев#include "include/TBalanceNode.h"TDatValue * TBalanceNode::GetCopy(){    TBalanceNode *tmp = new TBalanceNode(Key, pValue, nullptr, nullptr, Bal::BalOK);    return tmp;}        /*-------------------------------------------*/Bal TBalanceNode::GetBalance(void) const{    return Balance;}        /*-------------------------------------------*/void TBalanceNode::SetBalance(Bal bal){    Balance = bal;}```Реализация класса __TBalanceTree__:```c++// TBalanceTree.h// Сбалансированные деревья поиска (AVL-деревья)#ifndef _BALANCETREE_H_#define _BALANCETREE_H_#include "TTreeTable.h"#include "TBalanceNode.h"enum class Height { OK, Inc };class  TBalanceTree : public TTreeTable {protected:    Height InsBalanceTree(PTBalanceNode &pNode, TKey k, PTDatValue pVal);    Height LeftTreeBalancing(PTBalanceNode &pNode);  // баланс. левого поддерева    Height RightTreeBalancing(PTBalanceNode &pNode); // баланс. правого поддереваpublic:    TBalanceTree() :TTreeTable() {} // конструктор    //основные методы    virtual void InsRecord(TKey k, PTDatValue pVal) override final; // вставить    virtual void DelRecord(TKey k) override final;                  // удалить};typedef TBalanceTree *PTBalanceTree;#endif// TBalanceTree.cpp// Сбалансированные деревья поиска (AVL-деревья)#include "include/TBalanceTree.h"Height TBalanceTree::InsBalanceTree(PTBalanceNode &pNode, TKey k, PTDatValue pVal){    Height HeightIndex = Height::OK;    if (pNode == nullptr) { // вставка вершины        pNode = new TBalanceNode(k, pVal);        HeightIndex = Height::Inc;        DataCount++;    }    else if (k < pNode->GetKey()) {        if (InsBalanceTree((PTBalanceNode&)pNode->pLeft, k, pVal) == Height::Inc) {            HeightIndex = LeftTreeBalancing(pNode);        }    }    else if (k > pNode->GetKey()) {        if (InsBalanceTree((PTBalanceNode&)pNode->pRight, k, pVal) == Height::Inc) {            HeightIndex = RightTreeBalancing(pNode);        }    }    else {        SetRetCode(TabRecDbl);        HeightIndex = Height::OK;    }    return HeightIndex;}        /*-------------------------------------------*/Height TBalanceTree::LeftTreeBalancing(PTBalanceNode &pNode){    Height HeightIndex = Height::OK;    switch (pNode->GetBalance()) {    case Bal::BalRight:        pNode->SetBalance(Bal::BalOK);        HeightIndex = Height::OK;        break;    case Bal::BalOK:        pNode->SetBalance(Bal::BalLeft);        HeightIndex = Height::Inc;        break;    case Bal::BalLeft:        PTBalanceNode p1, p2;        p1 = PTBalanceNode(pNode->GetLeft());        if (p1->GetBalance() == Bal::BalLeft) {            pNode->pLeft = p1->pRight;            p1->pRight = pNode;            pNode->SetBalance(Bal::BalOK);            pNode = p1;        }        else {            p2 = PTBalanceNode(p1->GetRight());            p1->pRight = p2->pLeft;            p2->pLeft = p1;            pNode->pLeft = p2->pRight;            p2->pRight = pNode;            if (p2->GetBalance() == Bal::BalLeft) {                pNode->SetBalance(Bal::BalRight);            }            else {                pNode->SetBalance(Bal::BalOK);            }            if (p2->GetBalance() == Bal::BalRight) {                p1->SetBalance(Bal::BalLeft);            }            else {                p1->SetBalance(Bal::BalOK);            }            pNode = p2;        }        pNode->SetBalance(Bal::BalOK);        HeightIndex = Height::OK;    }    return HeightIndex;}        /*-------------------------------------------*/Height TBalanceTree::RightTreeBalancing(PTBalanceNode &pNode){    Height HeightIndex = Height::OK;    switch (pNode->GetBalance()) {    case Bal::BalLeft:        pNode->SetBalance(Bal::BalOK);        HeightIndex = Height::OK;        break;    case Bal::BalOK:        pNode->SetBalance(Bal::BalRight);        HeightIndex = Height::Inc;        break;    case Bal::BalRight:        PTBalanceNode p1, p2;        p1 = PTBalanceNode(pNode->GetRight());        if (p1->GetBalance() == Bal::BalRight) {            pNode->pRight = p1->pLeft;            p1->pLeft = pNode;            pNode->SetBalance(Bal::BalOK);            pNode = p1;        }        else {            p2 = PTBalanceNode(p1->GetLeft());            p1->pLeft = p2->pRight;            p2->pRight = p1;            pNode->pRight = p2->pLeft;            p2->pLeft = pNode;            if (p2->GetBalance() == Bal::BalRight) {                pNode->SetBalance(Bal::BalLeft);            }            else {                pNode->SetBalance(Bal::BalOK);            }            if (p2->GetBalance() == Bal::BalLeft) {                p1->SetBalance(Bal::BalRight);            }            else {                p1->SetBalance(Bal::BalOK);            }            pNode = p2;        }        pNode->SetBalance(Bal::BalOK);        HeightIndex = Height::OK;    }    return HeightIndex;}        /*-------------------------------------------*/void TBalanceTree::InsRecord(TKey k, PTDatValue pVal){    if (IsFull()) {        SetRetCode(TabFull);    }    else {        InsBalanceTree((PTBalanceNode&)pRoot, k, pVal);    }}void TBalanceTree::DelRecord(TKey k){    if (FindRecord(k) == nullptr) {        SetRetCode(TabNoRec);    }    else {        PTTreeNode tmp = pRoot;        while (!St.empty())            St.pop();        while (tmp->GetKey() != k) {            St.push(tmp);            if (tmp->GetKey() < k)                tmp = tmp->GetRight();            else                tmp = tmp->GetLeft();        }        TKey k2 = tmp->GetKey();        // удаление листа        if ((tmp->pLeft == nullptr) && (tmp->pRight == nullptr)) {            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = nullptr;                    if (prev->GetLeft() == tmp)                        prev->pLeft = nullptr;                }            }            else {                pRoot = nullptr;            }            delete tmp;            DataCount--;        }        // удаление звена с одним потомком (справа)        else if (tmp->pLeft == nullptr) {            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = tmp->pRight;                    if (prev->GetLeft() == tmp)                        prev->pLeft = tmp->pRight;                }            }            else {                pRoot = tmp->GetRight();            }            delete tmp;            DataCount--;        }        // удаление звена с одним потомком (слева)        else if (tmp->pRight == nullptr) {            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = tmp->pLeft;                    if (prev->GetLeft() == tmp)                        prev->pLeft = tmp->pLeft;                }            }            else {                pRoot = tmp->GetLeft();            }            delete tmp;            DataCount--;        }        // удаление звена с двумя потомками        else {            PTTreeNode down_left = tmp->GetRight();            while (down_left->GetLeft() != nullptr)                down_left = down_left->pLeft;            down_left->pLeft = tmp->GetLeft();            if (!St.empty()) {                PTTreeNode prev = St.top();                if (prev != nullptr) {                    if (prev->GetRight() == tmp)                        prev->pRight = tmp->pRight;                    if (prev->GetLeft() == tmp)                        prev->pLeft = tmp->pRight;                }            }            else {                pRoot = tmp->GetRight();            }            delete tmp;            DataCount--;        }        if (pRoot != nullptr) {            if (k2 < pRoot->GetKey()) {                LeftTreeBalancing((PTBalanceNode&)pRoot);            }            else  if (k2 > pRoot->GetKey()) {                RightTreeBalancing((PTBalanceNode&)pRoot);            }        }    }}```## ТестированиеТесты были разделены на три группы: - тесты для класса, представляющего объекты-значения для записей таблицы- тесты для таблиц с непрерывной памятью- тесты для таблиц, использующих деревьяТесты для класса __TTabRecord__:```c++#include <gtest/gtest.h>#include "include/TTabRecord.h"TEST(TabRecord, Can_Create_TabRecord) {    ASSERT_NO_THROW(TTabRecord rec1("abc"));}TEST(TabRecord, Can_Set_Key) {    TTabRecord rec1;    ASSERT_NO_THROW(rec1.SetKey("abc"));}TEST(TabRecord, Can_Get_Key) {    string s = "cba";    TTabRecord rec1("abc");        rec1.SetKey(s);    bool keys_equality = (s == rec1.GetKey()) && (rec1.GetKey() != "abc");    ASSERT_TRUE(keys_equality);}TEST(TabRecord, Can_Set_Value) {    TTabRecord rec1("abc");    int val = 123;    ASSERT_NO_THROW(rec1.SetValuePtr((PTDatValue)&val));}TEST(TabRecord, Can_Get_Value) {    TTabRecord rec1("abc");    int val = 123, expected_val;    rec1.SetValuePtr((PTDatValue)&val);    expected_val = *(int*)(rec1.GetValuePtr());    EXPECT_EQ(val, expected_val);}TEST(TabRecord, Records_With_Equal_Keys_Are_Equal) {    TTabRecord rec1("abc");    TTabRecord rec2("abc");    ASSERT_TRUE(rec1 == rec2);}TEST(TabRecord, Records_With_Not_Equal_Keys_Are_Not_Equal) {    TTabRecord rec1("abc");    TTabRecord rec2("cba");    ASSERT_FALSE(rec1 == rec2);}TEST(TabRecord, Record_With_Bigger_Key_Is_Less) {    TTabRecord rec1("aaa"), rec2("aab");    ASSERT_TRUE(rec2 > rec1);}TEST(TabRecord, Record_With_Less_Key_Is_Less) {    TTabRecord rec1("aaa"), rec2("aab");    ASSERT_TRUE(rec1 < rec2);}TEST(TabRecord, Can_Assign_Record) {    TTabRecord rec1("abc"), rec2;    rec2 = rec1;    ASSERT_TRUE(rec1 == rec2);}TEST(TabRecord, Assigned_Record_Has_Its_own_Mem) {    TTabRecord rec1("abc"), rec2;    rec2 = rec1;    rec2.SetKey("cba");    ASSERT_FALSE(rec1 == rec2);}```__Подтверждение успешного прохождения тестов:__![Tests.jpg](http://i.imgur.com/PpTCyR0.jpg "Tests.jpg")__Тесты для таблиц с непрерывной памятью:__```c++#include <gtest/gtest.h>#include "include/TArrayTable.h"#include "include/TScanTable.h"#include "include/TSortTable.h"TEST(ScanTable, Can_Create_ScanTable) {    ASSERT_NO_THROW(TScanTable table(5));}TEST(ScanTable, Can_Insert_Record) {    TScanTable* table = new TScanTable(5);    int i = 123;    ASSERT_NO_THROW((table->InsRecord("abc", (TDatValue*)&i)));}TEST(ScanTable, Can_Get_Current_Record) {    TScanTable* table = new TScanTable(5);    int i = 123;    TTabRecord rec, expected_rec("abc");    (table->InsRecord("abc", (TDatValue*)&i));    rec = *(table->GetCurrRecord());    ASSERT_TRUE(rec == expected_rec);}TEST(ScanTable, Can_Get_Table_Size) {    TScanTable* table = new TScanTable(5);    EXPECT_EQ(5, table->GetTabSize());}TEST(ScanTable, Full_Table_Is_Full) {    TScanTable* table = new TScanTable(5);    int numbers[5];    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table->InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    ASSERT_TRUE(table->IsFull());}TEST(ScanTable, Can_Set_Current_Position) {    TScanTable* table = new TScanTable(5);    int numbers[5];    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table->InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    table->SetCurrentPos(2);    ASSERT_TRUE("aaac" == table->GetKey());}TEST(ScanTable, Can_Get_Current_Position) {    TScanTable* table = new TScanTable(5);    int numbers[5];    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table->InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    table->SetCurrentPos(3);    EXPECT_EQ(3, table->GetCurrentPos());}TEST(ScanTable, Can_Reset_Position) {    TScanTable* table = new TScanTable(5);    int numbers[5];    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table->InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    table->SetCurrentPos(3);    table->Reset();    EXPECT_EQ(0, table->GetCurrentPos());}TEST(ScanTable, Can_Go_Next_Record) {    TScanTable* table = new TScanTable(5);    int numbers[5];    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table->InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    table->GoNext();    table->GoNext();    bool correctness = (2 == table->GetCurrentPos()) &&                        ("aaac" == table -> GetKey());    ASSERT_TRUE(correctness);}TEST(ScanTable, Can_Find_Record) {    TScanTable* table = new TScanTable(5);    int* i = new int(1);    i[0] = 5;    table->InsRecord("aaaa", (TDatValue*)&i[0]);    i = new int(1);    i[0] = 2;    table->InsRecord("aaab", (TDatValue*)&i[0]);    i = new int(1);    i[0] = 3;    table->InsRecord("aaba", (TDatValue*)i);    i = new int(1);    i[0] = 4;    table->InsRecord("aabc", (TDatValue*)i);    EXPECT_EQ(2, *((int*)(table->FindRecord("aaab"))));}TEST(ScanTable, Can_Delete_Record) {    TScanTable* table = new TScanTable(5);    int numbers[5];    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table->InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    ASSERT_NO_THROW(table->DelRecord("aaac"));    EXPECT_TRUE(nullptr == table->FindRecord("aaac"));}TEST(SortTable, Can_Assign_Table) {        TSortTable table(5), atable(1);        int numbers[5], n = 5;        string s = "aaa";        for (int i = 0; i < 5; i++) {            char smb = 'a' + i;            numbers[i] = i;            table.InsRecord(s + smb, (TDatValue*)&(numbers[i]));        }        atable.InsRecord("aaa", (PTDatValue)&n);    ASSERT_NO_THROW(atable = table);}TEST(SortTable, Assigned_Table_Has_Its_Own_Mem) {    TSortTable table(5), atable(1);    int numbers[5], n = 5;    string s = "aaa";    for (int i = 0; i < 5; i++) {        char smb = 'a' + i;        numbers[i] = i;        table.InsRecord(s + smb, (TDatValue*)&(numbers[i]));    }    atable.InsRecord("aaa", (PTDatValue)&n);    atable = table;    table.DelRecord("aaac");    bool correctness = (table.FindRecord("aaac") == nullptr) &&                       (3, *((int*)(atable.FindRecord("aaac"))));    ASSERT_TRUE(correctness);}TEST(SortTable, Can_Set_And_Get_Sort_Method) {    TSortTable* table = new TSortTable(5);    int i = 5;    table->SetSortMethod(INSERT_SORT);    EXPECT_TRUE(table->GetSortMethod() == INSERT_SORT);}TEST(SortTable, Can_Use_Different_Sort_Methods) {    TSortTable* table = new TSortTable(5);    int* i = new int(1);    i[0] = 5;    table->SetSortMethod(INSERT_SORT);    ASSERT_NO_THROW(table->InsRecord("aaaa", (TDatValue*)&i[0]));    i = new int(1);    i[0] = 4;    table->SetSortMethod(MERGE_SORT);    ASSERT_NO_THROW(table->InsRecord("aaab", (TDatValue*)&i[0]));    i = new int(1);    i[0] = 3;    table->SetSortMethod(QUICK_SORT);    ASSERT_NO_THROW(table->InsRecord("aaac", (TDatValue*)&i[0]));    i = new int(1);    i[0] = 4;    table->SetSortMethod(INSERT_SORT);    ASSERT_NO_THROW(table->InsRecord("aaad", (TDatValue*)&i[0]));    EXPECT_EQ(3, *((int*)(table->FindRecord("aaac"))));}```__Подтверждение успешного прохождения тестов:__![Tests.jpg](http://i.imgur.com/nCyHrMo.jpg "Tests.jpg")__Тесты для таблиц, использующих деревья:__```c++#include <gtest/gtest.h>#include "include/TTreeTable.h"#include "include/TBalanceTree.h"TEST(TreeNode, Can_Create_Tree_Node) {    ASSERT_NO_THROW(TTreeNode node());}TEST(TreeNode, Can_Place_Nodes_In_Tree) {    int* i = new int(1);    i[0] = 5;    TTreeNode left("aaaa", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 4;    TTreeNode right("aaac", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 10;    TTreeNode Center("aaab", (PTDatValue)&i[0], &left, &right);    EXPECT_EQ(Center.GetLeft(), &left);    EXPECT_EQ(Center.GetRight(), &right);}TEST(BalanceNode, Can_Create_Balanced_Tree_Node) {    EXPECT_NO_FATAL_FAILURE(TBalanceNode TBN);}TEST(TreeTable, Can_Create_Tree_Table) {    EXPECT_NO_FATAL_FAILURE(TTreeTable table);}TEST(TreeTable, Can_Insert_Record) {    int* i = new int(1);    i[0] = 3;    TTreeTable* table = new TTreeTable();    ASSERT_NO_THROW(table->InsRecord("aaaa", (PTDatValue)&i[0]));}TEST(TreeTable, Can_Get_Key) {    int* i = new int(1);    i[0] = 3;    TTreeTable* table = new TTreeTable();    table->InsRecord("aaaa", (PTDatValue)&i[0]);    table->Reset();    EXPECT_EQ("aaaa", table->GetKey());}TEST(TreeTable, Can_Get_Value) {    int* i = new int(1);    i[0] = 3;    TTreeTable* table = new TTreeTable();    table->InsRecord("aaaa", (PTDatValue)&i[0]);    table->Reset();    EXPECT_EQ(3, *((int*)table->GetValuePtr()));}TEST(TreeTable, Can_Find_Record) {    int* i = new int(1);    i[0] = 3;    TTreeTable* table = new TTreeTable();    table->InsRecord("aaaa", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 5;    table->InsRecord("aaae", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 2;    table->InsRecord("aaad", (PTDatValue)&i[0]);    EXPECT_EQ(*(int*)table->FindRecord("aaae"), 5);}TEST(BalanceTree, Can_Create_Balanced_Tree) {    ASSERT_NO_THROW(TBalanceTree tree);}TEST(BalanceTree, Can_Add_And_Find_Record) {    int* i = new int(1);    i[0] = 3;    TBalanceTree* table = new TBalanceTree();    table->InsRecord("aaai", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 5;    table->InsRecord("aaba", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 1;    table->InsRecord("acaa", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 2;    table->InsRecord("aaab", (PTDatValue)&i[0]);    i = new int(1);    i[0] = 4;    table->InsRecord("aage", (PTDatValue)&i[0]);    EXPECT_EQ(*(int*)table->FindRecord("aaab"), 2);}```__Подтверждение успешного прохождения тестов:__![Tests.jpg](http://i.imgur.com/GqpiQbA.jpg "Tests.jpg")## Используемые инструменты- Система контроля версий [Git][git].- Фреймворк для написания автоматических тестов [Google Test][gtest].- Среда разработки Microsoft Visual Studio 2013, Visual Studio 2015.## ВыводВыполнение данной лабораторной работы помогло закрепить начальные навыки командной разработки программ, показало, что скорость выполнения и качество работы существенно зависит от распределения обязанностей между членами команды.В ходе лабораторной работы были разработаны классы, представляющие различные способы организации таблиц. В перспективе данные наработки могут быть использованы для создания программного комплекса, обеспечивающего возможность работы пользователя с таблицами. <!-- LINKS -->[git]:         https://git-scm.com/book/ru/v2[gtest]:       https://github.com/google/googletest[sieve]:       http://habrahabr.ru/post/91112[git-guide]:   https://bitbucket.org/ashtan/mp2-lab1-set/src/ff6d76c3dcc2a531cefdc17aad5484c9bb8b47c5/docs/part1-git.md?at=master&fileviewer=file-view-default[gtest-guide]: https://bitbucket.org/ashtan/mp2-lab1-set/src/ff6d76c3dcc2a531cefdc17aad5484c9bb8b47c5/docs/part2-google-test.md?at=master&fileviewer=file-view-default[upstream]:    https://bitbucket.org/ashtan/mp2-lab1-set 